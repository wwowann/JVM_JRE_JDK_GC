
public class JvmComprehension {
//первый и единственный наш класс загрузчик передает на первоначальный уровень загрузки -
// в родительский загрузчик - системный загрузчик, обеспечивая поиск класса по иерархии,
// начиная с базового. Так как наш класс "самописный", то загрузчик не находит его в системном
// уровне и передает ниже - на уровень расширений - уровень JVM
//где происходит поиск. Соответственно загрузчик на этом уровне его не находит и передает
// на уровень ниже ищет класс "JvmComprehension" на уровне приложения. В JVM нашего класса нет,
// поэтому  загрузчик загружает наш класс в JVM на уровне "Bootstrap" и возвращается объект типа "Class"
//определить каким загрузчиком был загружен класс можно методом JvmComprehension.class.getClassLoader()
//правда из результата "jdk.internal.loader.ClassLoaders$AppClassLoader@4b1210ee" не очень понятно каким
    public static void main(String[] args) {
//в момент вызова метода "main" в стеке создается одноименный фрейм
        int i = 1;                      // 1
//во фрейме "main" создается примитив "int i=1"
        Object o = new Object();        // 2
//в кучу "heap" помещается вновь созданный объект "new Object()", а в стек, во фрейм "main"
//помещается переменная "о", которая ссылается на "new Object()" в куче
        Integer ii = 2;                 // 3
//в куче создается значение типа Integer - "2" ссылочной переменой "ii",
// которая помещается во фрейм "main" и ссылается на значение "2" в куче
        printAll(o, i, ii);             // 4
//в куче создается объект "printAll", на который ссылаются переменные "i","o" и "ii"
// из фрейма "main" в стеке. В свою очередь объект "printAll" ссылается в куче
// на объекты "new Object()" и "2", а также в стеке на примитив "int i = 1"
//сборщик мусора по идее здесь должен удалить строки 1-3, так как на них никакие
// объекты в программе больше не ссылаются, а вызываемый метод ничего не возвращает
        System.out.println("finished"); // 7
//создается в куче значение типа String - "finished", которое ссылается
// на системный метод "println" в Metaspace
//на этом этапе сборщик мусора удаляет ссылку на метод printAll(o, i, ii) и сам метод, что ниже по коду
// соответственно переменные и ссылки на системный метод "println" в самом методе "printAll" живут
// ровно столько, пока он исполняется
        System.out.println(JvmComprehension.class.getClassLoader());
    }

    private static void printAll(Object o, int i, Integer ii) {
//создается новый фрейм "printAll"
        Integer uselessVar = 700;                   // 5
//в куче создается значение типа Integer - "700" ссылочной переменой "uselessAll",
// которая помещается во фрейм "printAll" и ссылается на значение "700" в куче
        System.out.println(o.toString() + i + ii);  // 6
//создается в куче значение - результат выполнения "o.toString() + i + ii", которое ссылается
// на системный метод "println" в Metaspace
//во фрейме "println" создаются переменные "o", "int i = 1" и "ii", из них "o" и "ii " ссылаются в куче
//соответственно на "new Object()" и на "2". Переменная "о" в свою очередь ссылается на,
// веротянее всего, внешний системный метод "toString" в Metaspace.
// на результат выполнения "o.toString() + i + ii" ссылается также примитив "int i = 1" из фрейма
// "println"
    }
}


